// //
// // Created by dvirs on 4/22/2025.
// //
//
// #include "scheduler.h"
// #include "uthreads.h"
// #include <iostream>
// #include <unordered_set>
// #include <sys/time.h>
//
// // Static variables initialization
// int Scheduler::quantumUsecs = 0;
// int Scheduler::totalQuantums = 0;
// int Scheduler::currentTid = 0;
// int Scheduler::pendingDeletionTid = -1;
// std::unordered_map<int, Thread*> Scheduler::threads;
// std::queue<int> Scheduler::readyQueue;
// std::unordered_map<int, int> Scheduler::sleepingThreads;
//
// // Implementation of the private functions
// void Scheduler::removeFromReadyQueue(int tid) {
//   std::queue<int> tempQueue;
//   while (!readyQueue.empty()) {
//     int current = readyQueue.front();
//     readyQueue.pop();
//     if (current != tid) {
//       tempQueue.push(current);
//     }
//   }
//   readyQueue = tempQueue;
// }
//
// int Scheduler::nextAvailableTid() {
//   for (int tid = 0; tid < MAX_THREAD_NUM; ++tid) {
//     if (threads.count(tid) == 0) {
//       return tid;
//     }
//   }
//   return -1; // No available TID found
// }
//
// // void Scheduler::wakeSleepingThreads() {
// //   for (auto it = sleepingThreads.begin(); it != sleepingThreads.end(); ) {
// //     if (totalQuantums >= it->second) {
// //       int tid = it->first;
// //
// //       // In case the thread is blocked and sleeping, delete it from the sleeping list, but keep it blocked
// //       if (threads[tid]->getState() != BLOCKED) {
// //         readyQueue.push(tid);
// //       }
// //       it = sleepingThreads.erase(it);
// //     } else {
// //       ++it;
// //     }
// //   }
// // }
//
// void Scheduler::wakeSleepingThreads() {
//   for (auto it = sleepingThreads.begin(); it != sleepingThreads.end(); ) {
//     if (totalQuantums >= it->second) {
//       int tid = it->first;
//
//       // Check if the thread still exists
//       auto it_thread = threads.find(tid);
//       if (it_thread != threads.end()) {
//         Thread* t = it_thread->second;
//
//         // Wake it up only if it's not BLOCKED
//         if (t->getState() != BLOCKED) {
//           t->setState(READY);        // ✅ Set proper state
//           readyQueue.push(tid);      // ✅ Then push to readyQueue
//         }
//       }
//
//       it = sleepingThreads.erase(it); // ✅ Always erase after sleep time ends
//     } else {
//       ++it;
//     }
//   }
// }
//
//
// void Scheduler::timerHandler(int sig) {
//   wakeSleepingThreads();
//
//   if (currentTid != pendingDeletionTid) {
//     threads[currentTid]->setState(READY);
//     readyQueue.push(currentTid);
//   }
//   doContextSwitch();
// }
//
// void Scheduler::setupSignalHandler() {
//   struct sigaction sa = {};\
//
//
//   sa.sa_handler = &Scheduler::timerHandler;
//   sigemptyset(&sa.sa_mask); // optional: don't block any signals during handler
//   sa.sa_flags = 0;
//
//   if (sigaction(SIGVTALRM, &sa, nullptr) < 0) {
//     std::cerr << "system error: failed to set signal handler" << std::endl;
//     exit(1);
//   }
// }
//
// void Scheduler::setupTimer() {
//   struct itimerval timer{};
//   timer.it_value.tv_sec = quantumUsecs / 1000000;
//   timer.it_value.tv_usec = quantumUsecs % 1000000;
//   timer.it_interval.tv_sec = timer.it_value.tv_sec;
//   timer.it_interval.tv_usec = timer.it_value.tv_usec;
//
//   if (setitimer(ITIMER_VIRTUAL, &timer, nullptr) < 0) {
//     std::cerr << "system error: failed to set timer" << std::endl;
//     exit(1);
//   }
// }
//
// void Scheduler::blockTimerSignal() {
//   sigset_t set;
//   if (sigemptyset(&set) == -1) {
//     std::cerr << "system error: sigemptyset failed" << std::endl;
//     exit(1);
//   }
//   if (sigaddset(&set, SIGVTALRM) == -1) {
//     std::cerr << "system error: sigaddset failed" << std::endl;
//     exit(1);
//   }
//   if (sigprocmask(SIG_BLOCK, &set, nullptr) == -1) {
//     std::cerr << "system error: sigprocmask BLOCK failed" << std::endl;
//     exit(1);
//   }
// }
//
// void Scheduler::unblockTimerSignal() {
//   sigset_t set;
//   if (sigemptyset(&set) == -1) {
//     std::cerr << "system error: sigemptyset failed" << std::endl;
//     exit(1);
//   }
//   if (sigaddset(&set, SIGVTALRM) == -1) {
//     std::cerr << "system error: sigaddset failed" << std::endl;
//     exit(1);
//   }
//   if (sigprocmask(SIG_UNBLOCK, &set, nullptr) == -1) {
//     std::cerr << "system error: sigprocmask UNBLOCK failed" << std::endl;
//     exit(1);
//   }
// }
//
// // // Implementation of the Scheduler API
// int Scheduler::init(int quantum_usecs) {
//   quantumUsecs = quantum_usecs;
//
//   // Create main thread (tid 0)
//   auto* mainThread = new Thread(0, nullptr); // No entry point for main thread
//   threads[0] = mainThread;
//   mainThread->setState(RUNNING);
//   currentTid = 0;
//   mainThread->incrementQuantumCount();
//   totalQuantums = 1; // Main thread gets the first quantum
//
//   setupSignalHandler();
//   setupTimer();
//
//   return 0;
// }
//
// int Scheduler::spawn(void (*entryPoint)()) {
//   // Find the smallest available TID
//   int tid = nextAvailableTid();
//   if (tid == -1) {
//     std::cerr << "thread library error: reached maximum thread limit" << std::endl;
//     return -1;
//   }
//
//   // Create the new thread and add it to the map and ready queue
//   blockTimerSignal();
//   auto* newThread = new Thread(tid, entryPoint);
//   threads[tid] = newThread;
//   readyQueue.push(tid);
//   unblockTimerSignal();
//   return tid;
// }
//
// int Scheduler::terminate(int tid) {
//   blockTimerSignal();
//
//   if (tid == 0)
//   {
//     for (const auto &pair : threads)
//     {
//       delete pair.second;
//     }
//
//     threads.clear();
//     sleepingThreads.clear();
//     unblockTimerSignal();
//     exit(0);
//   }
//
//   if (threads[tid]->getState() == READY) {
//     removeFromReadyQueue(tid);
//   }
//
//   sleepingThreads.erase(tid);
//
//   // if (tid != currentTid) {
//   //   delete threads[tid];
//   //   threads.erase(tid);
//   //   unblockTimerSignal();
//   //   return 0;
//   // }
//
//   if (tid != currentTid) {
//     std::cerr << "[DEBUG] terminate(): deleting tid=" << tid << std::endl;
//     auto it = threads.find(tid);
//     if (it != threads.end()) {
//       delete it->second;
//       threads.erase(it);
//     }
//     unblockTimerSignal();
//     return 0;
//   }
//
//
//   //No option to terminate without other thread ready
//   if (readyQueue.empty()) {
//     std::cerr << "thread library error: no threads left to run after termination\n";
//     unblockTimerSignal();
//     return -1;
//   }
//   pendingDeletionTid = currentTid;
//   //unblockTimerSignal();
//   // Mark for pending deletion and perform context switch
//   std::cerr << "[DEBUG] terminate(): self-termination, pendingDeletionTid=" << pendingDeletionTid << std::endl;
//   doContextSwitch();
//
//
//   while (true) { pause(); }
//
//   return 0;
// }
//
// int Scheduler::block(int tid) {
//   Thread* thread = threads[tid];
//   ThreadState state = thread->getState();
//
//   if (state == BLOCKED) {
//     return 0; // Already blocked
//   }
//
//   if (state == READY) {
//     blockTimerSignal();
//     // Remove from ready queue
//     if(sleepingThreads.find(tid) != sleepingThreads.end()) {  // Remove from ready que if not sleeping
//       removeFromReadyQueue(tid);
//     }
//     thread->setState(BLOCKED);
//     unblockTimerSignal();
//     return 0;
//   }
//
//   if (tid == currentTid) {
//     blockTimerSignal();
//     thread->setState(BLOCKED);
//     if (readyQueue.empty()) { // No option to block without other ready thread
//       std::cerr << "thread library error: no threads left to run after blocking\n";
//       thread->setState(RUNNING);
//       unblockTimerSignal();
//       return -1;
//     }
//
//     unblockTimerSignal();
//     doContextSwitch();
//     return 0;
//   }
//
//   return 0;
// }
//
// int Scheduler::resume(int tid) {
//   Thread* thread = threads[tid];
//
//   // Do nothing if the thread is not currently blocked
//   if (thread->getState() != BLOCKED) {
//     return 0;
//   }
//
//   blockTimerSignal();
//   // If the thread is also sleeping, only wake it if its sleep time has passed
//   if (sleepingThreads.count(tid) > 0) {
//       // Sleep time has not passed yet, make it ready but keep it sleeping
//       threads[tid]->setState(READY);
//       unblockTimerSignal();
//       return 0;
//   }
//
//   // Push thread to the ready queue
//   thread->setState(READY);
//   readyQueue.push(tid);
//
//   unblockTimerSignal();
//   return 0;
// }
//
// int Scheduler::sleep(int numQuantums) {
//   blockTimerSignal();
//   Thread* thread = threads[currentTid];
//   if (readyQueue.empty() && thread->getState() == RUNNING) { // No option to sleep without other thread ready
//     std::cerr << "thread library error: no threads left to run after sleep\n";
//     unblockTimerSignal();
//     return -1;
//   }
//
//   // Setting the state of the thread to ready and sleeping
//   thread->setState(READY);
//   sleepingThreads[currentTid] = totalQuantums + numQuantums;
//
//   unblockTimerSignal();
//   doContextSwitch();
//   return 0;
// }
//
// void Scheduler::doContextSwitch() {
//   blockTimerSignal();
//
//   // Save the current thread's environment
//   int ret_val = sigsetjmp(threads[currentTid]->getEnv(), 1);
//
//   // if (ret_val != 0) {
//   //   // Returning to this thread
//   //   if (pendingDeletionTid != -1) {
//   //     sleepingThreads.erase(pendingDeletionTid);
//   //     delete threads[pendingDeletionTid];
//   //     threads.erase(pendingDeletionTid);
//   //     pendingDeletionTid = -1;
//   //   }
//   //   unblockTimerSignal();
//   //   return;
//   // }
//
//   if (ret_val != 0) {
//     std::cerr << "[DEBUG] doContextSwitch(): returned to tid=" << currentTid << std::endl;
//     if (pendingDeletionTid != -1) {
//       std::cerr << "[DEBUG] doContextSwitch(): deleting pendingTid=" << pendingDeletionTid << std::endl;
//     }
//     if (pendingDeletionTid != -1) {
//       sleepingThreads.erase(pendingDeletionTid);
//
//       auto it = threads.find(pendingDeletionTid);
//       if (it != threads.end()) {
//         delete it->second;
//         threads.erase(it);
//         std::cerr << "[DEBUG] doContextSwitch(): deletion done for tid=" << pendingDeletionTid << std::endl;
//       }
//
//       pendingDeletionTid = -1;
//     }
//     unblockTimerSignal();
//     return;
//   }
//
//   int nextTid = readyQueue.front();
//   readyQueue.pop();
//   currentTid = nextTid;
//   threads[currentTid]->setState(RUNNING);
//   threads[currentTid]->incrementQuantumCount();
//   totalQuantums++;
//
//   setupTimer();
//   unblockTimerSignal();
//   // --- DEBUG: BEGIN ---
//   std::cerr << "[DEBUG] doContextSwitch(): currentTid=" << currentTid
//             << ", readyQueue size=" << readyQueue.size() << std::endl;
//   std::cerr << "[DEBUG] doContextSwitch(): pendingDeletionTid=" << pendingDeletionTid << std::endl;
//   std::cerr << "[DEBUG] doContextSwitch(): switching to tid=" << nextTid << std::endl;
//   // --- DEBUG: END ---
//   if (threads.find(currentTid) == threads.end()) {
//     std::cerr << "[DEBUG] doContextSwitch(): ERROR - trying to jump to deleted thread " << currentTid << std::endl;
//     exit(1);
//   }
//   std::cerr << "[DEBUG] doContextSwitch(): jumping to tid=" << currentTid << std::endl;
//   std::cerr << "[DEBUG] doContextSwitch(): Thread*=" << threads[currentTid] << std::endl;
//   std::cerr << "[DEBUG] doContextSwitch(): thread state=" << threads[currentTid]->getState() << std::endl;
//   if (threads.find(currentTid) == threads.end() || threads[currentTid] == nullptr)
//   {
//     std::cerr << "[DEBUG] FATAL: Attempting to jump to invalid or null thread " << currentTid << std::endl;
//     exit(1);
//   }
//   siglongjmp(threads[currentTid]->getEnv(), 1);
// }
//
// int Scheduler::getTid() {
//   return currentTid;
// }
//
// Thread* Scheduler::getThreadById(int tid) {
//   if (threads.count(tid) == 0) return nullptr;
//   return threads[tid];
// }
//
// int Scheduler::getTotalQuantums() {
//   return totalQuantums;
// }
//
// int Scheduler::getQuantums(int tid) {
//   if (threads.count(tid) == 0) {
//     std::cerr << "thread library error: invalid tid" << std::endl;
//     return -1;
//   }
//   return threads[tid]->getQuantumCount();
// }


